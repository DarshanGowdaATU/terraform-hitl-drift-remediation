name: Detect Terraform Drift

on:
  schedule:
    - cron: "* 5 * * *" # every 5 minutes
  workflow_dispatch:
    inputs:
      force_slack:
        type: boolean
        default: false
        description: "Post to Slack even without drift"

concurrency:
  group: drift-${{ github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read

env:
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"
  AWS_REGION: "us-east-1"
  TF_DIR: "terraform"
  SLACK_CHANNEL: "C097WJUFJCU"
  OIDC_ROLE_ARN: "arn:aws:iam::147997134125:role/GitHubTerraformPlanRole"
  TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache

jobs:
  detect:
    name: Detect & Notify
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS (OIDC AssumeRole)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup tools
        run: |
          sudo apt-get update
          sudo apt-get install -y pipx jq
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          mkdir -p "$HOME/.terraform.d/plugin-cache"

      - name: Who am I (sanity)
        run: aws sts get-caller-identity

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
          terraform_wrapper: false  # preserve detailed exit codes

      # Cache Terraform providers (speed up init/plan)
      - name: Cache .terraform providers
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.TF_DIR }}/.terraform
            ~/.terraform.d/plugin-cache
          key: tf-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}

      - name: Terraform init
        working-directory: ${{ env.TF_DIR }}
        run: terraform init -input=false -no-color

      # Get current Terraform workspace (sanitized)
      - name: Get Terraform workspace
        id: ws
        working-directory: ${{ env.TF_DIR }}
        run: |
          ws="$(terraform workspace show 2>/dev/null || echo default)"
          safe_ws="$(echo "$ws" | tr -cd '[:alnum:]._-' )"
          echo "name=$safe_ws" >> $GITHUB_OUTPUT

      - name: Plan (refresh-only, detailed exit code)
        id: plan
        working-directory: ${{ env.TF_DIR }}
        run: |
          set +e
          # Capture stdout/stderr separately for better failure UX
          terraform plan -refresh-only -detailed-exitcode -lock-timeout=2m -out=tfplan.out -no-color -input=false \
            1>plan_stdout.txt 2>plan_error.txt
          code=$?
          echo "exitcode=$code" >> $GITHUB_OUTPUT

          if [ $code -eq 1 ]; then
            # Failure: keep a stub JSON for downstream steps; drift_id derived from error content
            echo '{}' > plan.json
            sha="$(sha256sum plan_error.txt | awk '{print $1}')"
            echo "drift_id=${sha::12}-${GITHUB_RUN_ID}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Success (0) or Drift (2): render artifacts and drift_id from plan.json
          cp plan_stdout.txt plan.txt
          terraform show -json tfplan.out > plan.json
          sha="$(sha256sum plan.json | awk '{print $1}')"
          echo "drift_id=${sha::12}-${GITHUB_RUN_ID}" >> $GITHUB_OUTPUT
          exit 0

      - name: Debug plan exit code
        run: echo "Plan exit code was:${{ steps.plan.outputs.exitcode }}"

      - name: Upload plan artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ steps.plan.outputs.drift_id }}
          path: |
            ${{ env.TF_DIR }}/tfplan.out
            ${{ env.TF_DIR }}/plan.txt
            ${{ env.TF_DIR }}/plan.json
            ${{ env.TF_DIR }}/plan_error.txt
            ${{ env.TF_DIR }}/plan_stdout.txt
          retention-days: 7

      - name: Install Checkov (CIS scan)
        run: pipx install checkov

      - name: Run Checkov
        id: checkov
        run: |
          checkov -d "$TF_DIR" -o json > checkov.json || true
          # Handle both Checkov 2.x (object) and 3.x (array) JSON
          fails=$(jq -r '
            if type=="array" then
              map((.results.failed_checks // []) | length) | add
            else
              (.results.failed_checks // []) | length
            end' checkov.json 2>/dev/null || echo 0)
          warns=$(jq -r '
            if type=="array" then
              ( (map((.results.parsing_errors // []) | length) | add)
                + (map((.results.resource_skipped_checks // []) | length) | add) )
            else
              (((.results.parsing_errors // []) | length)
                + ((.results.resource_skipped_checks // []) | length))
            end' checkov.json 2>/dev/null || echo 0)
          echo "failed=${fails}" >> $GITHUB_OUTPUT
          echo "warned=${warns}" >> $GITHUB_OUTPUT

      - name: Upload Checkov report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: checkov-${{ steps.plan.outputs.drift_id }}
          path: checkov.json
          retention-days: 7

      - name: Build Slack payload (drift or forced)
        if: ${{ steps.plan.outputs.exitcode == '2' || (github.event_name == 'workflow_dispatch' && github.event.inputs.force_slack == 'true' && steps.plan.outputs.exitcode != '1') }}
        id: payload
        env:
          DRIFT_ID: ${{ steps.plan.outputs.drift_id }}
          EXIT: ${{ steps.plan.outputs.exitcode }}
          FAILS: ${{ steps.checkov.outputs.failed }}
          WARNS: ${{ steps.checkov.outputs.warned }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          WS: ${{ steps.ws.outputs.name }}
          REGION: ${{ env.AWS_REGION }}
          BLOCK_MODE: ${{ env.CIS_BLOCK_MODE }}
        run: |
          set -euo pipefail
          export LC_ALL=C

          env_tag="${WS}/${REGION}"
          # escape '-' so tr doesn't treat it as a range
          safe_env_tag="$(echo "$env_tag" | tr -cd '[:alnum:]._/\- ' | tr ' /' '--')"

          # ---- Primary: derive counts from plan.json ----
          summary="$(jq -r '
            (.resource_changes // [])
            | reduce .[] as $rc (
                {adds:0, changes:0, destroys:0};
                .adds     += ( (( $rc.change.actions // [] ) | index("create"))  | if .==null then 0 else 1 end )
              | .changes  += ( (( $rc.change.actions // [] ) | index("update"))  | if .==null then 0 else 1 end )
              | .destroys += ( (( $rc.change.actions // [] ) | index("delete"))  | if .==null then 0 else 1 end )
            )' "$TF_DIR/plan.json")"

          adds="$(echo "$summary" | jq -r .adds)"
          changes="$(echo "$summary" | jq -r .changes)"
          destroys="$(echo "$summary" | jq -r .destroys)"

          # Coerce to integers if jq returned null/empty
          printf '%s' "$adds"     | grep -Eq '^[0-9]+$' || adds=0
          printf '%s' "$changes"  | grep -Eq '^[0-9]+$' || changes=0
          printf '%s' "$destroys" | grep -Eq '^[0-9]+$' || destroys=0

          total=$((adds + changes + destroys))

          # Pre-render JSON-based lists (up to 10) with bullets
          creates_list_json=$(jq -r '
            [(.resource_changes // [])[]
              | select((.change.actions // []) | index("create")) | .address] | .[0:10]
            | if length==0 then "" else map("• `" + . + "`") | join("\n") end
          ' "$TF_DIR/plan.json")
          updates_list_json=$(jq -r '
            [(.resource_changes // [])[]
              | select((.change.actions // []) | index("update")) | .address] | .[0:10]
            | if length==0 then "" else map("• `" + . + "`") | join("\n") end
          ' "$TF_DIR/plan.json")
          deletes_list_json=$(jq -r '
            [(.resource_changes // [])[]
              | select((.change.actions // []) | index("delete")) | .address] | .[0:10]
            | if length==0 then "" else map("• `" + . + "`") | join("\n") end
          ' "$TF_DIR/plan.json")

          # ---- Fallback: parse plan.txt if JSON says 0/0/0 ----
          if [ "$total" -eq 0 ]; then
            creates_txt=$(grep -E '^[[:space:]]*\+ resource "' "$TF_DIR/plan.txt" | sed -E 's/^ *\+ resource "([^"]+)" "([^"]+)".*$/\1.\2/' | head -n 10 || true)
            updates_txt=$(grep -E '^[[:space:]]*~ resource "' "$TF_DIR/plan.txt" | sed -E 's/^ *~ resource "([^"]+)" "([^"]+)".*$/\1.\2/' | head -n 10 || true)
            deletes_txt=$(grep -E '^[[:space:]]*- resource "' "$TF_DIR/plan.txt" | sed -E 's/^ *- resource "([^"]+)" "([^"]+)".*$/\1.\2/' | head -n 10 || true)

            adds=$(printf "%s\n" "$creates_txt" | grep -c . || echo 0)
            changes=$(printf "%s\n" "$updates_txt" | grep -c . || echo 0)
            destroys=$(printf "%s\n" "$deletes_txt" | grep -c . || echo 0)

            if [ -n "$creates_txt" ]; then creates="$(printf "%s\n" "$creates_txt" | sed 's/^/• `/' | sed 's/$/`/')"; else creates="none"; fi
            if [ -n "$updates_txt" ]; then updates="$(printf "%s\n" "$updates_txt" | sed 's/^/• `/' | sed 's/$/`/')"; else updates="none"; fi
            if [ -n "$deletes_txt" ]; then deletes="$(printf "%s\n" "$deletes_txt" | sed 's/^/• `/' | sed 's/$/`/')"; else deletes="none"; fi
          else
            creates="${creates_list_json:-none}"
            updates="${updates_list_json:-none}"
            deletes="${deletes_list_json:-none}"
          fi

          # Short plan diff for context (first 30 +/-/~ lines)
          diff_snippet="$(grep -E '^[[:space:]]*[~+-]' "$TF_DIR/plan.txt" | head -n 30 || true)"

          # ---- CIS block vs. Approve/Reject buttons ----
          if [ "$BLOCK_MODE" = "block" ] && [ "${FAILS:-0}" -gt 0 ]; then
            printf '%s\n' '{ "type": "section", "text": { "type": "mrkdwn", "text": "*Remediation blocked:* failing CIS checks present. Approval disabled." } }' > /tmp/block.json
          else
            jq -n --arg env "$safe_env_tag" --arg drift "$DRIFT_ID" '{
              type:"actions",
              elements:[
                {type:"button", text:{type:"plain_text", text:"Approve Remediation"}, style:"primary", action_id:("approve_remediation::"+$env+"::"+$drift), value:"approve"},
                {type:"button", text:{type:"plain_text", text:"Reject"}, style:"danger", action_id:("reject_remediation::"+$env+"::"+$drift), value:"reject"}
              ]
            }' > /tmp/block.json
          fi

          # ---- Final Slack payload ----
          jq -n \
            --arg channel "$SLACK_CHANNEL" \
            --arg drift "$DRIFT_ID" \
            --arg runurl "$RUN_URL" \
            --arg fails "$FAILS" \
            --arg warns "$WARNS" \
            --arg adds "$adds" \
            --arg changes "$changes" \
            --arg destroys "$destroys" \
            --arg creates "$creates" \
            --arg updates "$updates" \
            --arg deletes "$deletes" \
            --arg diff "$diff_snippet" \
            --arg envtag "$env_tag" \
            --slurpfile last /tmp/block.json \
            '
            {
              channel: $channel,
              text: "Terraform drift detected",
              blocks: [
                { "type": "header",
                  "block_id": ("drift::" + $drift),
                  "text": { "type": "plain_text", "text": ("Terraform Drift Detected — " + $envtag) } },
                { "type": "section", "fields": [
                    { "type": "mrkdwn", "text": "*Env:*\n\($envtag)" },
                    { "type": "mrkdwn", "text": "*Drift ID:*\n\($drift)" },
                    { "type": "mrkdwn", "text": "*Repo/Run:*\n<\($runurl)|Open run>" }
                  ]},
                { "type": "section", "fields": [
                    { "type": "mrkdwn", "text": "*Adds:* \($adds)" },
                    { "type": "mrkdwn", "text": "*Changes:* \($changes)" },
                    { "type": "mrkdwn", "text": "*Destroys:* \($destroys)" }
                  ]},
                { "type": "section", "text": { "type": "mrkdwn", "text": ("*Creates (up to 10):*\n\($creates)") } },
                { "type": "section", "text": { "type": "mrkdwn", "text": ("*Updates (up to 10):*\n\($updates)") } },
                { "type": "section", "text": { "type": "mrkdwn", "text": ("*Deletes (up to 10):*\n\($deletes)") } },
                { "type": "section", "text": { "type": "mrkdwn", "text": ("*Plan snippet:*\n```\($diff)```") } },
                { "type": "context", "elements": [
                    { "type": "mrkdwn", "text": "*CIS pre-check:* \($fails) failing checks, \($warns) warnings" }
                  ]},
                $last[0]
              ]
            }' > payload.json


      - name: Post to Slack (drift or forced)
        if: steps.payload.outcome == 'success'
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          DRIFT_ID: ${{ steps.plan.outputs.drift_id }}
        run: |
          resp="$(curl -sS -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
            -H "Content-type: application/json; charset=utf-8" \
            --data @payload.json)"
          echo "$resp" | tee /tmp/slack_response.json
          jq -e '.ok == true' /tmp/slack_response.json > /dev/null
          # Persist channel + ts so Flask can thread remediation result
          jq -r --arg drift "$DRIFT_ID" '{channel:.channel, ts:.ts, drift_id:$drift}' /tmp/slack_response.json \
            > "slack-${DRIFT_ID}.json"

      - name: Build Slack payload (plan failed — manual runs only)
        if: ${{ steps.plan.outputs.exitcode == '1' && github.event_name == 'workflow_dispatch' }}
        id: payload_failed
        env:
          DRIFT_ID: ${{ steps.plan.outputs.drift_id }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          WS: ${{ steps.ws.outputs.name }}
          REGION: ${{ env.AWS_REGION }}
        run: |
          env_tag="${WS}/${REGION}"
          err_tail="$(tail -n 40 "$TF_DIR/plan_error.txt" 2>/dev/null || echo "No error output available.")"
          jq -n \
            --arg channel "$SLACK_CHANNEL" \
            --arg drift "$DRIFT_ID" \
            --arg runurl "$RUN_URL" \
            --arg envtag "$env_tag" \
            --arg err "$err_tail" \
            '
            {
              channel: $channel,
              text: "Terraform plan failed",
              blocks: [
                { "type": "header",
                  "block_id": ("plan_failed::" + $drift),
                  "text": { "type": "plain_text", "text": ("Terraform Plan Failed — " + $envtag) } },
                { "type": "section", "fields": [
                    { "type": "mrkdwn", "text": "*Env:*\n\($envtag)" },
                    { "type": "mrkdwn", "text": "*Drift/Run ID:*\n\($drift)" },
                    { "type": "mrkdwn", "text": "*Repo/Run:*\n<\($runurl)|Open run>" }
                  ]},
                { "type": "section", "text": { "type": "mrkdwn", "text": ("*Error (last 40 lines):*\n```\($err)```") } }
              ]
            }' > payload_failed.json

      - name: Post to Slack (plan failed)
        if: steps.payload_failed.outcome == 'success'
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          DRIFT_ID: ${{ steps.plan.outputs.drift_id }}
        run: |
          resp="$(curl -sS -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
            -H "Content-type: application/json; charset=utf-8" \
            --data @payload_failed.json)"
          echo "$resp" | tee /tmp/slack_response_failed.json
          jq -e '.ok == true' /tmp/slack_response_failed.json > /dev/null
          jq -r --arg drift "$DRIFT_ID" '{channel:.channel, ts:.ts, drift_id:$drift}' /tmp/slack_response_failed.json \
            > "slack-${DRIFT_ID}.json"

      - name: Upload Slack metadata (for threaded remediation reply)
        if: ${{ (steps.payload.outcome == 'success') || (steps.payload_failed.outcome == 'success') }}
        uses: actions/upload-artifact@v4
        with:
          name: slack-${{ steps.plan.outputs.drift_id }}
          path: slack-${{ steps.plan.outputs.drift_id }}.json
          retention-days: 7
          
      - name: Record t2, write metrics, ingest
        if: ${{ (steps.payload.outcome == 'success') || (steps.payload_failed.outcome == 'success') }}
        env:
          DRIFT_ID: ${{ steps.plan.outputs.drift_id }}
          FAILS: ${{ steps.checkov.outputs.failed }}
          METRICS_INGEST_URL: ${{ env.METRICS_INGEST_URL }}
          METRICS_INGEST_TOKEN: ${{ secrets.METRICS_INGEST_TOKEN }}
        run: |
          echo "T2=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_ENV

          # Coerce FAILS to a number (default 0)
          PRE="${FAILS:-0}"
          if ! [[ "$PRE" =~ ^[0-9]+$ ]]; then PRE=0; fi

          # Write metrics JSON without heredocs
          jq -n \
            --arg drift "$DRIFT_ID" \
            --arg t0 "$T0" \
            --arg t1 "$T1" \
            --arg t2 "$T2" \
            --argjson pre "$PRE" \
            '{drift_id:$drift, t0:$t0, t1:$t1, t2:$t2, pre_cis_failed:$pre}' \
            > "metrics-${DRIFT_ID}.json"

          # Optional ingest to Flask
          if [ -n "${METRICS_INGEST_URL}" ]; then
            curl -sS -X POST -H "Content-Type: application/json" \
              -H "X-Auth-Token: ${METRICS_INGEST_TOKEN}" \
              --data-binary @"metrics-${DRIFT_ID}.json" \
              "${METRICS_INGEST_URL}" || true
          fi


      - name: No drift (exit=0)
        if: ${{ steps.plan.outputs.exitcode == '0' && !(github.event_name == 'workflow_dispatch' && github.event.inputs.force_slack == 'true') }}
        run: echo "No drift."
