name: Detect Terraform Drift

on:
  schedule:
    - cron: "*/30 * * * *"
  push:
    paths:
      - 'terraform/**'
  workflow_dispatch:
    inputs:
      simulate_drift:
        description: "Create a small manual drift before planning?"
        required: false
        default: "false"
        type: choice
        options: ["false","true"]
      drift_type:
        description: "Type of drift to simulate"
        required: false
        default: "s3_tag"
        type: choice
        options: ["s3_tag"]
      s3_bucket_name:
        description: "S3 bucket name (managed by Terraform) for s3_tag drift"
        required: false
        default: ""

jobs:
  detect-drift:
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: terraform

    env:
      AWS_REGION: us-east-1
      TF_IN_AUTOMATION: "true"

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify backend (S3 + DynamoDB)
        run: |
          aws s3 ls s3://tf-state-l00187927 >/dev/null
          aws dynamodb describe-table --table-name terraform-locks --query 'Table.TableStatus' >/dev/null

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      # ---- OPTIONAL: create a tiny, safe drift (S3 tag) ----
      - name: Simulate drift (S3 tag)
        if: ${{ github.event.inputs.simulate_drift == 'true' && github.event.inputs.drift_type == 's3_tag' && github.event.inputs.s3_bucket_name != '' }}
        env:
          BUCKET: ${{ github.event.inputs.s3_bucket_name }}
        run: |
          echo "Creating drift on bucket: ${BUCKET}"
          # Read current tags (ignore if none)
          aws s3api get-bucket-tagging --bucket "${BUCKET}" >/tmp/tags.json 2>/dev/null || echo '{"TagSet":[]}' >/tmp/tags.json
          echo "Original tags:"; cat /tmp/tags.json || true

          # Add or toggle a harmless tag
          python3 - << 'PY'
          import json,sys,os
          path="/tmp/tags.json"
          with open(path) as f:
            data=json.load(f)
          tags={t["Key"]:t["Value"] for t in data.get("TagSet",[])}
          # Toggle a small drift tag
          tags["drift_test"] = "on" if tags.get("drift_test")!="on" else "off"
          new={"TagSet":[{"Key":k,"Value":v} for k,v in tags.items()]}
          print(json.dumps(new))
          PY
          | tee /tmp/new_tags.json

          aws s3api put-bucket-tagging --bucket "${BUCKET}" --tagging file:///tmp/new_tags.json
          echo "Drift tag applied."

      - name: Terraform Init (uses remote S3 backend)
        run: terraform init -input=false

      - name: Terraform Plan for Drift Detection
        id: plan
        run: |
          set +e
          PLAN_OUTPUT=$(terraform plan -input=false -no-color -detailed-exitcode -out=tfplan.out 2>&1)
          PLAN_EXIT=$?
          echo "PLAN_EXIT=$PLAN_EXIT" >> $GITHUB_ENV
          echo "PLAN_OUTPUT<<EOF" >> $GITHUB_ENV
          echo "$PLAN_OUTPUT" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          set -e

      - name: Send Slack Notification if Drift Detected
        if: env.PLAN_EXIT == '2'
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          REPO: ${{ github.repository }}
          BRANCH: ${{ github.ref_name }}
          SHA: ${{ github.sha }}
        run: |
          cat > payload.json <<'JSON'
          {
            "channel": "${SLACK_CHANNEL_ID}",
            "text": "⚠️ Terraform drift detected. Approve remediation?",
            "blocks": [
              {
                "type": "header",
                "text": { "type": "plain_text", "text": "⚠️ Drift detected", "emoji": true }
              },
              {
                "type": "section",
                "fields": [
                  { "type": "mrkdwn", "text": "*Repo:*\n${REPO}" },
                  { "type": "mrkdwn", "text": "*Branch:*\n${BRANCH}" },
                  { "type": "mrkdwn", "text": "*Commit:*\n\`${SHA}\`" },
                  { "type": "mrkdwn", "text": "*Run:*\n<${RUN_URL}|Open>" }
                ]
              },
              { "type": "section", "text": { "type": "mrkdwn", "text": "Approve remediation?" } },
              {
                "type": "actions",
                "elements": [
                  { "type": "button", "text": { "type": "plain_text", "text": "Approve ✅" }, "style": "primary", "action_id": "approve_remediation", "value": "approve" },
                  { "type": "button", "text": { "type": "plain_text", "text": "Reject ❌" }, "style": "danger", "action_id": "reject_remediation", "value": "reject" }
                ]
              }
            ]
          }
          JSON

          curl -sS -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
            -H "Content-type: application/json; charset=utf-8" \
            --data @payload.json | tee /tmp/slack_response.json

          if command -v jq >/dev/null 2>&1; then
            jq -e '.ok == true' /tmp/slack_response.json > /dev/null
          else
            echo "jq not found; skipping ok-check"
          fi
